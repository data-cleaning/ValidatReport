\documentclass[a4paper, 11pt,titlepage]{article}
\usepackage[english]{babel}
\usepackage{amsthm, amsmath, amssymb}
\usepackage{graphicx}% includegraphics
\usepackage{array}   % outline of p{} elements in tables
\usepackage{enumitem}% control spacing in lists
\usepackage{caption} % for non-floating tables
\usepackage{subcaption} % for subfigures
\usepackage{listings}

\lstset{numbers=left,
language=C
}

\usepackage[
  pdfborder={0,0,0},
  colorlinks=true,
  linkcolor=black,
  citecolor=black,
  urlcolor=blue
]{hyperref}
\usepackage{natbib}
\bibliographystyle{chicago}

\newtheorem{demand}{Demand}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}


\renewcommand{\familydefault}{\sfdefault}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\waar}{{\normalfont \texttt{True}}}
\newcommand{\onwaar}{{\normalfont \texttt{False}}}
\newcommand{\na}{{\normalfont \texttt{NA}}}

\newcommand{\la}[1]{\boldsymbol{#1}}

\title{Validation report structure}
\author{Mark van der Loo and Olav ten Bosch}
\date{\today\\
\vspace{1cm}
Deliverable xx for the ESSnet Validat Integration
}



\setlength{\parindent}{0pt}
\setlength{\parskip}{2ex}

\begin{document}

\maketitle{}

\tableofcontents{}

\newpage

\input{introduction.tex}

\input{demands.tex}

\input{identifying.tex}
 
\section{Basic validation reports}
The concepts of a validation result and a validation event now allow us to give
a recursive definition of a basic validation report. These reports are aimed to
satisfy the demands for results to be identifiable and reports to be
composable.
%
\begin{definition}[Basic validation report]\leavevmode
\begin{enumerate}[topsep=0pt,itemsep=0pt]
\item The empty set $\{\}$ is a basic validation report.
\item If $\la{c}=(t,r,d)$ is a confrontation and $v$ its validation result,
then $\{(\la{c},v)\}$ is a basic validation report.
\item If $V$ and $W$ are basic validation reports, then the set union $V\cup W$
is also a validation report.
\end{enumerate}
\label{def:basicvalidationreport}
\end{definition}
%
By formally combining a validation result with a representation of the physical
event that created it, the results become identifiable
(Demand~\ref{dem:identify}). The set structure and inclusion of set union in
the definition guarantees combinability of the reports
(Demand~\ref{dem:combine}).

It follows immediately that any subset of a basic validation report is a basic
validation report. Also we inherit from set theory that for basic validation
reports $V$ and $W$, the set difference $V-W$ is also a validation report as
well as the set intersection $V\cap W$.

Now that we have a conceptual definition of a basic validation report, we can
move forward and define the identifying pieces of information to be stored in
the validation events, both on a logical and a technical level.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Structure of a basic validation report}
\label{sect:basicreportstructure}
In the following we present the information to be stored in a validation report
in a number of tables. The information is chosen so validation results are
identifiable. In these tables, each row represents an information item to be
included. Each row has four colums with the following information.
%
\begin{enumerate}
\item Item: the name of the information item.
\item Format: logical format of the data in the item. Allowed formats are: \code{string},
\code{numeric}, \code{enum} (with categories defined in the description
column), \code{datetime} and \code{-}. The latter indicates that the format is
free, including the possibility to include user-defined objects.
\item Description: a short description of the item. More detailed descriptions
might follow after the table.
\item Example: an example.
\end{enumerate}
%
We distinguish between information which is mandatory and information that
is recommended. This is indicated in the caption of each table. Some
information items may be extended with user-defined information. Whether
this is the case is indicated at the bottom of each table.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Identification of a physical validation event.}
\label{sect:idevent}
Recall that a \emph{confrontation} is defined as a triple $(t,r,d)$ where $r$
and $d$ identify the data and rules confronted and $t$ identifies the actual
physical event that generated the result
(Definition~\ref{def:validationevent}).  This section identifies the
information components that make up $t$.
%
\begin{center}
\captionof{table}{Mandatory identification of a physical validation event $t$.}
\label{tab:idve}
\begin{tabular}{|lp{15mm}p{0.34\textwidth}p{0.34\textwidth}|}
\hline
\textbf{Item} & \textbf{Format} & \textbf{Description} &\textbf{Example}\\
\hline
time          & datetime & Time marking the completion of a validation event. & \code{20170212T101530+0100}\\
actor         & string        a  & Software that or person who created the validation result. & \code{R package validate version 0.1.7}\\
\hline
\multicolumn{4}{|l|}{The number of slots defining a validation event is \textbf{extendable}.
}\\
\hline
\end{tabular}
\end{center}


\begin{center}
\captionof{table}{Recommended information on a physical validation event $t$.}
\begin{tabular}{|lp{15mm}p{0.34\textwidth}p{0.34\textwidth}|}
\hline
\textbf{Item} & \textbf{Format} & \textbf{Description} &\textbf{Example}\\
\hline
agent   & \multicolumn{1}{c}{-} & Actor (person, institute, dpt) responsible for executing the validation event & dpt. of data validation, Eurostat\\
trigger & \multicolumn{1}{c}{-} & Actor (person, institute, dpt) responsible for triggering the event  & John Statistician, Statistics Netherlands\\
\hline
\end{tabular}
\label{tab:recommendedevent}.
\end{center}
The recommended slots of Table~\ref{tab:recommendedevent} are useful, especially when validation is executed as a (remote) service.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Identification of a validation rule}
\label{sect:idrule}
%
\begin{center}
\captionof{table}{Mandatory identification of validation rule $r$.}
\begin{tabular}{|lp{15mm}p{0.34\textwidth}p{0.34\textwidth}|}
\hline
\textbf{Item} & \textbf{Format} & \textbf{Description} &\textbf{Example}\\
language      & string   & Language and version in which a rule is expressed & R/validate version 0.1.7\\
expression    & string   & Expression defining the rule           & \code{age >= 0}\\
severity      & enum     & \code{`error'}, \code{`warning'},
                           or \code{`information'}                & \code{`error'}\\ 

\hline
\multicolumn{4}{|l|}{The number of slots defining a validation rule is \textbf{extendable}.
}\\
\hline
\end{tabular}
\end{center}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Identification of the validated data}
\label{sect:iddata}
With the validated data, we mean precisely the set of datapoints that was
necessary to evaluate the current validation rule. Since rules are are defined
independent of a data set instance, this identification can only take place
during the physical validation event. To be clear, consider the following
example. Given the rule \code{turnover >= 0}. Such a rule is implicitly
understood to be checked for each turnover value separately. Hence, for a
dataset with $n$ records, $n$ validation events will take place, each resulting
in a single validation value. The data to be identified with each result is a
single data point (i.e. a single turnover value). Now consider the rule that
states \code{mean(profit) > 0}, evaluated on the same dataset. Each profit
value in the dataset is involved in the evaluation of this rule. We therefore
conclude that in general, we need to identify a set of data points to make a
validation result identifiable.


The methodology handbook on validation prescribes a generic model to 
identify a single datapoint \citep[Chapter~5]{zio2015methodology}. In short,
one identifies the value of a data point by fixing
\begin{itemize}
\item the population $U$ to which it pertains;
\item the event $\tau$ that lead to its observation;
\item the population unit $u$ from which a property was observed, and
\item the attribute $X$ that was measured.
\end{itemize}
Here, the term `population' should be interpreted very generally. It may be the
human population of a country or region, but it can also be a population of
companies, countries, events, emails, and so on. Similarly, the event that lead
to an observation can be the receiving of transmitted data from an institute.
In the handbook, a data point is defined as a value (from some domain) paired
with a tuple $(U,\tau,u,X)$ that identifies it.




\begin{center}
\captionof{table}{Mandatory identification of validated data $d$.}
\begin{tabular}{|lp{15mm}p{0.34\textwidth}p{0.34\textwidth}|}
\hline
\textbf{Item} & \textbf{Format} & \textbf{Description} &\textbf{Example}\\
data    &\multicolumn{1}{c}{-} & A set of key(s) 
identifying the data used in evaluating the validation rule.
&  $\{$(`Dutch inhabitants', `EU-SILC2016, `Ria Respondent', `Income')$\}$\\
\hline
\multicolumn{4}{|l|}{The number of slots defining a validation rule is \textbf{extendable}.
}\\
\hline
\end{tabular}
\end{center}

When the set of keys consists of a set of $(U,\tau,u,X)$-tuples as defined in
the methodological handbook on validation, the report will identify data
involved in validation completely free of any context involving the sender, the
process, institutes involved and so on. 

The format is left open since the denotation of keys typically depends on
local storage schemes and formats. Also, the open format allows for reduction
of storage format by referring to a well defined data set and stating a query
statement that would reproduce the exact data points used in the validation
event. Such a format does require extra standardization between sender and
receiver of the report.


\subsubsection{Validation result}
\label{sect:valres}
A validation result can have three different values and is hence conceived
logically as a enumeration type.
\begin{center}
\captionof{table}{Mandatory format for the validation result $v$.}
\begin{tabular}{|lp{15mm}p{0.34\textwidth}p{0.34\textwidth}|}
\hline
\textbf{Item} & \textbf{Format} & \textbf{Description} &\textbf{Example}\\
value  & \code{enum} & \waar{}, \onwaar{}, or \na{}    &\waar{}\\
\hline
\multicolumn{4}{|l|}{The number of slots defining a validation result \textbf{not extendable}.
}\\
\hline
\end{tabular}
\end{center}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Aggregation}
In the context of validation, commonly reported aggregates include the total
number or fraction of rules violated or the number or fraction of records  that
violate a certain rule. The latter aggregates may be reported for the whole
population or for each relevant subpopulation (e.g. by economic activity for a
business survey). 


Before discussing how we endow machine-readable validation reports with
identifiable and combinable aggregates, it is useful to point out some of the
subtleties that arise when thinking of aggregation is a general way. The first
subtlety has to do with counting rules and counting validation results.
Consider as an example the rules \code{turnover >= 0} and \code{mean(profit) >=
0}.  When applied to a set of $n$ business records containing the variables
\code{turnover} and \code{profit}, the first rule is evaluated $n$ times in $n$
validation events, yielding $n$ validation results. The second rule is
evaluated in a single validation event, yielding a single validation result,
regardless of the number of records in the dataset. This means that an
aggregate such as `the total number of rules violated' is ill-defined. It is
only meaningful to talk about `the number of events that resulted in
\onwaar{}'. 

The second subtlety is that a set of aggregates can again be combined to form
new aggregates. For example, in a first step we may compute the fraction of
events yielding \onwaar{} per economic sector. In a next step we count for how
many sectors this number is less than or equal to 0.05.

Figure~\ref{fig:graphs} illustrates the above points as a graph-like structure.
Suppose we start with a basic report containing five validation results. We can
add an aggregate counting the number of passes in a certain subset
(Figure~\ref{fig:graph1}).  In Figure~\ref{fig:graph2}, a second count is
added, as well as an overall count that is composed of the two low-level
aggregates. Figure~\ref{fig:graph3} depicts a situation where a subset of
validation results are combined to form aggregates of several types: the number
of passes and the fraction of passes.
%
\begin{figure}[!t]
  \centering
  \begin{subfigure}[b]{0.7\textwidth}
    \includegraphics[width=\textwidth]{fig/graph1.pdf}
    \caption{Validation report with a single aggregated value.}
    \label{fig:graph1}
  \end{subfigure}
  \begin{subfigure}[b]{0.7\textwidth}
    \includegraphics[width=\textwidth]{fig/graph2.pdf}
    \caption{Validation report with multiple aggregates.}
    \label{fig:graph2}
  \end{subfigure}
  \begin{subfigure}[b]{0.7\textwidth}
    \includegraphics[width=\textwidth]{fig/graph3.pdf}
    \caption{Validation report with aggregates of various types.}
    \label{fig:graph3}
  \end{subfigure}
  \caption{Structure of validation reports including aggregates, of varying complexity.}
  \label{fig:graphs}
\end{figure}

These examples suggest that aggregates can be interpreted as nodes in a
directed graph where the edges (arrows) point from the aggregate to the nodes
used to compute the contents of the node. Nodes that have no outgoing edges
(leaves) correspond one-to-one with validation results---they can be considered
a trivial aggregate. The collection of nodes and edges contain sufficient
structure to make the representation of validation reports identifiable,
combinable, and (recursively) aggregable. In the following paragraph we define
more closely the type of graph that can be used to represent an aggregation
structure.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Aggregation graphs}
\label{sect:aggregationgraphs}
Graphs are well-known mathematical structures that represent connectivity
between objects. Indeed, the  study of graphs dates back to the 18th century
when Leonhard \citet{euler1741solutio} solved the famous K\"oningsberger
bridges problem.  For our purposes, a graph will serve as a model to store
validation results, aggregates thereof, and the operations that lead to the
aggregated values.

The need for a graph structure rather then a more simple record-like structure
arises from the demand that reports be combinable to a new report.  To see
this, consider the following example. Two institutes validate a dataset with
turnover values against the rule \code{turnover >= 0}. The first institute
reports the fraction of passes, while the second institute reports the results
for each individual record. If these reports were naively combined, one could
misinterpret the fractional value reported by the first institute as pertaining
to the separate values reported by the second institute. A second example
occurs when the first institute creates a report containing both the individual
results and the aggregated fraction of passes. If this report is to be
augmented with new information, for example when new records come in it should
be clear from the report that the reported fraction of passes does not pertain
to the records added later.


Graphs basically consist of elements of some set, called \emph{nodes} or
\emph{vertices} and connections between them, which are called \emph{edges} or
\emph{arrows} if they are directed. Structured information can be stored by
endowing the nodes and edges with parcels of data.  Depending on the type and
number of edges allowed between the nodes, graphs are classified in a broad
number of types.  Below we define simple directed graph that comes close to our
purpose of structuring validation aggregates.
%
\begin{definition}
A \emph{simple finite directed graph} is a pair  $(V,E)$ where $V$ is a finite set and $E$
is a set of pairs $(v_1,v_2)$ with $v_1,v_2\in V$ and $v_1\not=v_2$.
\end{definition}
In this definition, the term \emph{simple} means that there are no loops (edges
that start where they begin, like $(v_1,v_1)$). The term \emph{directed} mean
that edges have a direction: the edge $(v_1,v_2)$ can be thought of as an
arrow, pointing from $v_1$ to $v_2$ and therefore differs from ($v_2$,$v_1$).
The term \emph{simple} also indicates that each pair of nodes is connected by
at most two, opposite pointing arrows.


A validation report can be represented by a more special graph. Since
aggregation works bottom-up and not top-down, we define the following.
\begin{definition}
A \emph{directed acyclic graph} is a simple finite directed graph $(V,E)$ where
for any $v_1$ and $v_2$ in $V$ at most one of $(v_1,v_2)$ and $(v_2,v_1)$ are
in $E$.
\end{definition}
%
The term `directed acyclic graph' is often shortened to DAG in literature. This
particular structure is widely researched in fields related to computer
science. For example, the DAG stands model for data processing flow in the
SPARK model for distributed computing \citep{gupta2003spark}. In mathematics
the term `oriented graph' is also used for this structure.


Simple graphs have a natural rule of composition. The `sum' of two simple
(directed) graphs is obtained as the union of the two vertex sets and the union
of the two edge sets. For a DAG, this combination rule does not always apply
since we are not allowed to have more than a single edge between any pair of
nodes.  We therefore define the following compatibility rule for oriented
graphs.
\begin{definition}[Compatible DAGs]
Given two DAGs $G=(V,E)$ and $F=(V',E')$. These graphs are called
\emph{compatible} when the combination
\begin{align*}
G\oplus F = (V\cup V', E\cup E'),
\end{align*}
is also an oriented graph.
\end{definition}
It is not hard to see that two oriented graphs are not compatible precisely
when $V\cap V'$ has at least two vertices $v_1$ and $v_2$ for which it holds
that $(v_1,v_2)\in E$ and $(v_2,v_1)\in E'$. Any software that combines
extended validation reports (validation reports including aggregates, to be
defined below) should therefore always check for compatibility of the reports
upon combination.








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Extended validation report structure}
Conceptually, the structure of an extended validation report is an directed
acyclic graph (DAG), where each node is either atomic (resulting from a
validation event) or an aggregate, possibly built from previous aggregates. The
atomic nodes store information on the used validation function, the data
involved and the event that created it. The aggregated nodes store information
on the aggregating function (sum, mean, $\ldots$) and the aggregation value
while the edges indicate which nodes were used to form an aggregate. 

To make sure that aggregate nodes can be added without loosing the property of
the graph being a DAG, we need to be able to uniquely identify them. This can
be done by thinking of an aggregate as a value that is created by an
aggregation event---analogous to a validation event. An aggregation event is
the physical activity that takes as input a set of nodes and an aggregation
function, and generates a numeric value. On a more formal level, we define the
following.
%
\begin{definition}[aggregate node]
An \emph{aggregation node} is a triple $(a,f,x)$ where $a$ uniquely corresponds
to the physical event creating the aggregate, $f$ identifies the function used for
aggregation and $x\in \mathbb{R}$ is the aggregate.
\end{definition}
Just as in Definition~\ref{def:validationevent}, this is not a definition in a
precise mathematical sense. Rather it is something that can be tested in a
particular practical (software) environment. The statement that the key $a$
uniquely corresponds to an aggregation event leaves open the possibility that
no information about that event is stored. The most important function of $a$
is to make the triple unique, even when the same aggregate is computed multiple
times.

We are now ready to define the extended validation report.
%
\begin{definition}[Extended validation report]\leavevmode
\label{def:extvalrep}
\begin{enumerate}
\item The empty graph $(\{\},\{\})$ is an extended validation report.
\item If $B$ is a basic validation report, the edgeless graph $(B, \{\})$ is an
extended validation report.
\item Given an extended validation report $(V,E)$  a subset $S\subseteq V$ and
a function $f:2^V\to\mathbb{R}$. Construct the aggregate node $v=(a,f,f(S))$.
The graph
\begin{displaymath}
\left(
V\cup \{v\}, E\cup \bigcup_{s\in S}\left\{( v, s )\right\}
\right)
\end{displaymath}
is an extended validation report.
\end{enumerate}
\end{definition}
Here, the first step is a formality, allowing one to have empty extended
validation reports. In the second step a basic validation report is lifted to
an extended validation report by endowing it with an empty set of edges. The
crucial step is step three. Here, an aggregate function is assumed that assigns
a numeric value to a set of nodes of an extended validation report.  The
aggregating function, its value, and an identifying key are combined to an
aggregate node which is then added to the existing node set. The set of edges
is extended with pairs $(v,s)$ where $v$ is the aggregate node and $s$ runs
over all nodes that were used to compute the aggregate.  The unique identifier
guarantees that the aggregation node is new to the set of vertices. If this
were not the case, it would under circumstances be possible to have two subsets
$S$ and $S'$ of $V$ such that $f(S)=f(S')$ while $S'\not=S$. This is
undesirable since it would leave open the possibility of creating directed
graphs which are not acyclic (and hence would introduce ambiguity in the
identification of aggregates).






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Structure of an extended validation report}
\label{sect:extendedreport}
In the following subsections we define the logical information values to be
stored in an extended validation report. Since by definition, the extended
validation report contains a basic validation report
(Definition~\ref{def:basicvalidationreport}), we will focus on the elements
that are new with respect to this.  These are the aggregate nodes and the edges
that connect aggregate nodes with each other and with basic nodes. We also add
a unique key to the leave nodes for the definition of leave nodes.

\subsubsection{Basic nodes (leaves)}
The leaves of the DAG we represent here correspond to the elements of 
the basic validation report. In the extended report we add a unique
identifying key to the elements of a basic report to facilitate the
definition of edges. Hence, we demand the following.

\begin{center}
\captionof{table}{Mandatory identification of a base node.}
\begin{tabular}{|lp{0.1\textwidth}p{0.64\textwidth}|}
\hline
\textbf{Item} & \textbf{Format} & \textbf{Description} \\
\hline
key           & string & Unique identifier labeling the base node  \\
confrontation & -      & A confrontation object, with contents as defined in
Sections~\ref{sect:idevent}, \ref{sect:idrule}, \ref{sect:iddata} and \ref{sect:valres}. \\
\hline
\multicolumn{3}{|l|}{The number of slots for a base node is \textbf{extendable}.}\\
\hline
\end{tabular}
\end{center}



\subsubsection{Aggregates}

\begin{center}
\captionof{table}{Mandatory identification of an aggregate.}
\begin{tabular}{|lp{0.1\textwidth}p{0.34\textwidth}p{0.30\textwidth}|}
\hline
\textbf{Item} & \textbf{Format} & \textbf{Description} &\textbf{Example}\\
\hline
key          & string & Unique identifier labeling the aggregate. & \\
aggregator   & string & The statistical method used to compute the aggregate & \code{sum}\\
value        & numeric& the computed value & $7.5$\\
\hline
\multicolumn{4}{|l|}{The number of slots for an aggregate node is \textbf{extendable}.
}\\
\hline
\end{tabular}
\end{center}


\subsubsection{Edges}
Edges indicate which nodes are used in the computation of an aggregate value.
\begin{center}
\captionof{table}{Mandatory identification of an edge.}
\begin{tabular}{|lp{0.1\textwidth}p{0.34\textwidth}p{0.30\textwidth}|}
\hline
\textbf{Item} & \textbf{Format} & \textbf{Description} &\textbf{Example}\\
\hline
start  & string & The key of an aggregate node. & \\
end    & string & The key of an aggregate or base node. & \\
\hline
\multicolumn{4}{|l|}{The number of slots for an edge is \textbf{extendable}.
}\\
\hline
\end{tabular}
\end{center}




\section{Technical standards}
In this section we define explicitly the technical data exchange
formats defined in the previous subsections.

\subsection{File encoding and data storage format per type}
Below we propose a JSON format \citep{ecma2013json} for exchanging data
validation reports.  Although it is a textual format, the JSON standard does
not impose restrictions on the encoding being used, leaving it explicitly to
standards built upon JSON to define an encoding \citep[pp ii]{ecma2013json}. In
this standard we follow the currently most widely applied standard (see
Figure~\ref{fig:encoding}) with the following demand.

\begin{center}
\captionof{table}{File encoding used for validation reports}
\label{tab:encoding}
\begin{tabular}{|p{0.97\textwidth}|}
\hline
Validation reports shall be encoded in \code{UTF-8}.\\
\hline
\end{tabular}
\end{center}

\begin{figure}[t]
\centering
\includegraphics[width=0.7\textwidth]{fig/encoding_use.pdf}
\caption{Percentages of encoding standards used on the web \citep{w3techs2017}.}
\label{fig:encoding}
\end{figure}

The different data types within a file are to be formatted according to
commonly used standards where possible. In particular, data in validation
reports shall be encoded as stated in Table~\ref{tab:dataformat}.
\begin{center}
\captionof{table}{Format of data types in validation reports.}
\begin{tabular}{|lp{0.92\textwidth}|}
\hline
1&Numbers shall be encoded in a valid decimal ISO/IEC/IEEE 60559:2011 (IEEE 754) format \\
2&Date-time data shall be denoted in ISO 8601 format \code{YYMMDDTHHmmss+HHMM}. \\
3&Enumerated data types are encoded as a string from the set predefined in the item's description.\\
\hline
\end{tabular}
\label{tab:dataformat}
\end{center}




\cleardoublepage
\subsection{JSON schema for the basic validation report}
\label{code:basicreport}
\lstinputlisting[frame=single
  , float=h
  , caption=JSON schema for basic validation report.]{../json/basic_validation_report.json}

\subsection{JSON schema for the extended validation report}


\clearpage{}
\bibliography{report}
\end{document}
